// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package usecases

import (
	"time"

	"github.com/blcvn/backend/services/auth-service/common/errors"
	"github.com/blcvn/backend/services/auth-service/dto"
	"github.com/blcvn/backend/services/auth-service/entities"
	mock "github.com/stretchr/testify/mock"
)

// NewMockIHashUtilities creates a new instance of MockIHashUtilities. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIHashUtilities(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIHashUtilities {
	mock := &MockIHashUtilities{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIHashUtilities is an autogenerated mock type for the iHashUtilities type
type MockIHashUtilities struct {
	mock.Mock
}

type MockIHashUtilities_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIHashUtilities) EXPECT() *MockIHashUtilities_Expecter {
	return &MockIHashUtilities_Expecter{mock: &_m.Mock}
}

// GenerateOpaqueToken provides a mock function for the type MockIHashUtilities
func (_mock *MockIHashUtilities) GenerateOpaqueToken() (string, errors.BaseError) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenerateOpaqueToken")
	}

	var r0 string
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func() (string, errors.BaseError)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() errors.BaseError); ok {
		r1 = returnFunc()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIHashUtilities_GenerateOpaqueToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateOpaqueToken'
type MockIHashUtilities_GenerateOpaqueToken_Call struct {
	*mock.Call
}

// GenerateOpaqueToken is a helper method to define mock.On call
func (_e *MockIHashUtilities_Expecter) GenerateOpaqueToken() *MockIHashUtilities_GenerateOpaqueToken_Call {
	return &MockIHashUtilities_GenerateOpaqueToken_Call{Call: _e.mock.On("GenerateOpaqueToken")}
}

func (_c *MockIHashUtilities_GenerateOpaqueToken_Call) Run(run func()) *MockIHashUtilities_GenerateOpaqueToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIHashUtilities_GenerateOpaqueToken_Call) Return(s string, baseError errors.BaseError) *MockIHashUtilities_GenerateOpaqueToken_Call {
	_c.Call.Return(s, baseError)
	return _c
}

func (_c *MockIHashUtilities_GenerateOpaqueToken_Call) RunAndReturn(run func() (string, errors.BaseError)) *MockIHashUtilities_GenerateOpaqueToken_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateTokenPairWithRefreshToken provides a mock function for the type MockIHashUtilities
func (_mock *MockIHashUtilities) GenerateTokenPairWithRefreshToken(sessionID string, refreshToken string, userInfo *entities.UserInfo) (*entities.Token, errors.BaseError) {
	ret := _mock.Called(sessionID, refreshToken, userInfo)

	if len(ret) == 0 {
		panic("no return value specified for GenerateTokenPairWithRefreshToken")
	}

	var r0 *entities.Token
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, string, *entities.UserInfo) (*entities.Token, errors.BaseError)); ok {
		return returnFunc(sessionID, refreshToken, userInfo)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, *entities.UserInfo) *entities.Token); ok {
		r0 = returnFunc(sessionID, refreshToken, userInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.Token)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, *entities.UserInfo) errors.BaseError); ok {
		r1 = returnFunc(sessionID, refreshToken, userInfo)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateTokenPairWithRefreshToken'
type MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call struct {
	*mock.Call
}

// GenerateTokenPairWithRefreshToken is a helper method to define mock.On call
//   - sessionID string
//   - refreshToken string
//   - userInfo *entities.UserInfo
func (_e *MockIHashUtilities_Expecter) GenerateTokenPairWithRefreshToken(sessionID interface{}, refreshToken interface{}, userInfo interface{}) *MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call {
	return &MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call{Call: _e.mock.On("GenerateTokenPairWithRefreshToken", sessionID, refreshToken, userInfo)}
}

func (_c *MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call) Run(run func(sessionID string, refreshToken string, userInfo *entities.UserInfo)) *MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *entities.UserInfo
		if args[2] != nil {
			arg2 = args[2].(*entities.UserInfo)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call) Return(token *entities.Token, baseError errors.BaseError) *MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call {
	_c.Call.Return(token, baseError)
	return _c
}

func (_c *MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call) RunAndReturn(run func(sessionID string, refreshToken string, userInfo *entities.UserInfo) (*entities.Token, errors.BaseError)) *MockIHashUtilities_GenerateTokenPairWithRefreshToken_Call {
	_c.Call.Return(run)
	return _c
}

// HashPassword provides a mock function for the type MockIHashUtilities
func (_mock *MockIHashUtilities) HashPassword(password string) (string, errors.BaseError) {
	ret := _mock.Called(password)

	if len(ret) == 0 {
		panic("no return value specified for HashPassword")
	}

	var r0 string
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (string, errors.BaseError)); ok {
		return returnFunc(password)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(password)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) errors.BaseError); ok {
		r1 = returnFunc(password)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIHashUtilities_HashPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPassword'
type MockIHashUtilities_HashPassword_Call struct {
	*mock.Call
}

// HashPassword is a helper method to define mock.On call
//   - password string
func (_e *MockIHashUtilities_Expecter) HashPassword(password interface{}) *MockIHashUtilities_HashPassword_Call {
	return &MockIHashUtilities_HashPassword_Call{Call: _e.mock.On("HashPassword", password)}
}

func (_c *MockIHashUtilities_HashPassword_Call) Run(run func(password string)) *MockIHashUtilities_HashPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIHashUtilities_HashPassword_Call) Return(s string, baseError errors.BaseError) *MockIHashUtilities_HashPassword_Call {
	_c.Call.Return(s, baseError)
	return _c
}

func (_c *MockIHashUtilities_HashPassword_Call) RunAndReturn(run func(password string) (string, errors.BaseError)) *MockIHashUtilities_HashPassword_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyAccessToken provides a mock function for the type MockIHashUtilities
func (_mock *MockIHashUtilities) VerifyAccessToken(token string) (*entities.UserSession, errors.BaseError) {
	ret := _mock.Called(token)

	if len(ret) == 0 {
		panic("no return value specified for VerifyAccessToken")
	}

	var r0 *entities.UserSession
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (*entities.UserSession, errors.BaseError)); ok {
		return returnFunc(token)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *entities.UserSession); ok {
		r0 = returnFunc(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserSession)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) errors.BaseError); ok {
		r1 = returnFunc(token)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIHashUtilities_VerifyAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyAccessToken'
type MockIHashUtilities_VerifyAccessToken_Call struct {
	*mock.Call
}

// VerifyAccessToken is a helper method to define mock.On call
//   - token string
func (_e *MockIHashUtilities_Expecter) VerifyAccessToken(token interface{}) *MockIHashUtilities_VerifyAccessToken_Call {
	return &MockIHashUtilities_VerifyAccessToken_Call{Call: _e.mock.On("VerifyAccessToken", token)}
}

func (_c *MockIHashUtilities_VerifyAccessToken_Call) Run(run func(token string)) *MockIHashUtilities_VerifyAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIHashUtilities_VerifyAccessToken_Call) Return(userSession *entities.UserSession, baseError errors.BaseError) *MockIHashUtilities_VerifyAccessToken_Call {
	_c.Call.Return(userSession, baseError)
	return _c
}

func (_c *MockIHashUtilities_VerifyAccessToken_Call) RunAndReturn(run func(token string) (*entities.UserSession, errors.BaseError)) *MockIHashUtilities_VerifyAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyPassword provides a mock function for the type MockIHashUtilities
func (_mock *MockIHashUtilities) VerifyPassword(hashedPassword string, password string) errors.BaseError {
	ret := _mock.Called(hashedPassword, password)

	if len(ret) == 0 {
		panic("no return value specified for VerifyPassword")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, string) errors.BaseError); ok {
		r0 = returnFunc(hashedPassword, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIHashUtilities_VerifyPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyPassword'
type MockIHashUtilities_VerifyPassword_Call struct {
	*mock.Call
}

// VerifyPassword is a helper method to define mock.On call
//   - hashedPassword string
//   - password string
func (_e *MockIHashUtilities_Expecter) VerifyPassword(hashedPassword interface{}, password interface{}) *MockIHashUtilities_VerifyPassword_Call {
	return &MockIHashUtilities_VerifyPassword_Call{Call: _e.mock.On("VerifyPassword", hashedPassword, password)}
}

func (_c *MockIHashUtilities_VerifyPassword_Call) Run(run func(hashedPassword string, password string)) *MockIHashUtilities_VerifyPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIHashUtilities_VerifyPassword_Call) Return(baseError errors.BaseError) *MockIHashUtilities_VerifyPassword_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIHashUtilities_VerifyPassword_Call) RunAndReturn(run func(hashedPassword string, password string) errors.BaseError) *MockIHashUtilities_VerifyPassword_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIUserRepository creates a new instance of MockIUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIUserRepository {
	mock := &MockIUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIUserRepository is an autogenerated mock type for the iUserRepository type
type MockIUserRepository struct {
	mock.Mock
}

type MockIUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIUserRepository) EXPECT() *MockIUserRepository_Expecter {
	return &MockIUserRepository_Expecter{mock: &_m.Mock}
}

// CreateUser provides a mock function for the type MockIUserRepository
func (_mock *MockIUserRepository) CreateUser(user *entities.RegisterPayload) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.RegisterPayload) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(user)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.RegisterPayload) *entities.UserInfo); ok {
		r0 = returnFunc(user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.RegisterPayload) errors.BaseError); ok {
		r1 = returnFunc(user)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIUserRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockIUserRepository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - user *entities.RegisterPayload
func (_e *MockIUserRepository_Expecter) CreateUser(user interface{}) *MockIUserRepository_CreateUser_Call {
	return &MockIUserRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", user)}
}

func (_c *MockIUserRepository_CreateUser_Call) Run(run func(user *entities.RegisterPayload)) *MockIUserRepository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.RegisterPayload
		if args[0] != nil {
			arg0 = args[0].(*entities.RegisterPayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUserRepository_CreateUser_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIUserRepository_CreateUser_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIUserRepository_CreateUser_Call) RunAndReturn(run func(user *entities.RegisterPayload) (*entities.UserInfo, errors.BaseError)) *MockIUserRepository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUserID provides a mock function for the type MockIUserRepository
func (_mock *MockIUserRepository) GetByUserID(userID string) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByUserID")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(userID)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *entities.UserInfo); ok {
		r0 = returnFunc(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) errors.BaseError); ok {
		r1 = returnFunc(userID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIUserRepository_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockIUserRepository_GetByUserID_Call struct {
	*mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - userID string
func (_e *MockIUserRepository_Expecter) GetByUserID(userID interface{}) *MockIUserRepository_GetByUserID_Call {
	return &MockIUserRepository_GetByUserID_Call{Call: _e.mock.On("GetByUserID", userID)}
}

func (_c *MockIUserRepository_GetByUserID_Call) Run(run func(userID string)) *MockIUserRepository_GetByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUserRepository_GetByUserID_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIUserRepository_GetByUserID_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIUserRepository_GetByUserID_Call) RunAndReturn(run func(userID string) (*entities.UserInfo, errors.BaseError)) *MockIUserRepository_GetByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUserName provides a mock function for the type MockIUserRepository
func (_mock *MockIUserRepository) GetByUserName(username string) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(username)

	if len(ret) == 0 {
		panic("no return value specified for GetByUserName")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(username)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *entities.UserInfo); ok {
		r0 = returnFunc(username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) errors.BaseError); ok {
		r1 = returnFunc(username)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIUserRepository_GetByUserName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserName'
type MockIUserRepository_GetByUserName_Call struct {
	*mock.Call
}

// GetByUserName is a helper method to define mock.On call
//   - username string
func (_e *MockIUserRepository_Expecter) GetByUserName(username interface{}) *MockIUserRepository_GetByUserName_Call {
	return &MockIUserRepository_GetByUserName_Call{Call: _e.mock.On("GetByUserName", username)}
}

func (_c *MockIUserRepository_GetByUserName_Call) Run(run func(username string)) *MockIUserRepository_GetByUserName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIUserRepository_GetByUserName_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIUserRepository_GetByUserName_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIUserRepository_GetByUserName_Call) RunAndReturn(run func(username string) (*entities.UserInfo, errors.BaseError)) *MockIUserRepository_GetByUserName_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserStatus provides a mock function for the type MockIUserRepository
func (_mock *MockIUserRepository) UpdateUserStatus(userID string, status int) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(userID, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserStatus")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, int) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(userID, status)
	}
	if returnFunc, ok := ret.Get(0).(func(string, int) *entities.UserInfo); ok {
		r0 = returnFunc(userID, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, int) errors.BaseError); ok {
		r1 = returnFunc(userID, status)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIUserRepository_UpdateUserStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserStatus'
type MockIUserRepository_UpdateUserStatus_Call struct {
	*mock.Call
}

// UpdateUserStatus is a helper method to define mock.On call
//   - userID string
//   - status int
func (_e *MockIUserRepository_Expecter) UpdateUserStatus(userID interface{}, status interface{}) *MockIUserRepository_UpdateUserStatus_Call {
	return &MockIUserRepository_UpdateUserStatus_Call{Call: _e.mock.On("UpdateUserStatus", userID, status)}
}

func (_c *MockIUserRepository_UpdateUserStatus_Call) Run(run func(userID string, status int)) *MockIUserRepository_UpdateUserStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIUserRepository_UpdateUserStatus_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIUserRepository_UpdateUserStatus_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIUserRepository_UpdateUserStatus_Call) RunAndReturn(run func(userID string, status int) (*entities.UserInfo, errors.BaseError)) *MockIUserRepository_UpdateUserStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockISessionRepository creates a new instance of MockISessionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockISessionRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockISessionRepository {
	mock := &MockISessionRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockISessionRepository is an autogenerated mock type for the iSessionRepository type
type MockISessionRepository struct {
	mock.Mock
}

type MockISessionRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockISessionRepository) EXPECT() *MockISessionRepository_Expecter {
	return &MockISessionRepository_Expecter{mock: &_m.Mock}
}

// CreateSession provides a mock function for the type MockISessionRepository
func (_mock *MockISessionRepository) CreateSession(userID string, refreshToken string, expiresAt time.Time) (string, errors.BaseError) {
	ret := _mock.Called(userID, refreshToken, expiresAt)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 string
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, string, time.Time) (string, errors.BaseError)); ok {
		return returnFunc(userID, refreshToken, expiresAt)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, time.Time) string); ok {
		r0 = returnFunc(userID, refreshToken, expiresAt)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, time.Time) errors.BaseError); ok {
		r1 = returnFunc(userID, refreshToken, expiresAt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockISessionRepository_CreateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSession'
type MockISessionRepository_CreateSession_Call struct {
	*mock.Call
}

// CreateSession is a helper method to define mock.On call
//   - userID string
//   - refreshToken string
//   - expiresAt time.Time
func (_e *MockISessionRepository_Expecter) CreateSession(userID interface{}, refreshToken interface{}, expiresAt interface{}) *MockISessionRepository_CreateSession_Call {
	return &MockISessionRepository_CreateSession_Call{Call: _e.mock.On("CreateSession", userID, refreshToken, expiresAt)}
}

func (_c *MockISessionRepository_CreateSession_Call) Run(run func(userID string, refreshToken string, expiresAt time.Time)) *MockISessionRepository_CreateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockISessionRepository_CreateSession_Call) Return(s string, baseError errors.BaseError) *MockISessionRepository_CreateSession_Call {
	_c.Call.Return(s, baseError)
	return _c
}

func (_c *MockISessionRepository_CreateSession_Call) RunAndReturn(run func(userID string, refreshToken string, expiresAt time.Time) (string, errors.BaseError)) *MockISessionRepository_CreateSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteAllUserSessions provides a mock function for the type MockISessionRepository
func (_mock *MockISessionRepository) DeleteAllUserSessions(userID string) errors.BaseError {
	ret := _mock.Called(userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAllUserSessions")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) errors.BaseError); ok {
		r0 = returnFunc(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockISessionRepository_DeleteAllUserSessions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAllUserSessions'
type MockISessionRepository_DeleteAllUserSessions_Call struct {
	*mock.Call
}

// DeleteAllUserSessions is a helper method to define mock.On call
//   - userID string
func (_e *MockISessionRepository_Expecter) DeleteAllUserSessions(userID interface{}) *MockISessionRepository_DeleteAllUserSessions_Call {
	return &MockISessionRepository_DeleteAllUserSessions_Call{Call: _e.mock.On("DeleteAllUserSessions", userID)}
}

func (_c *MockISessionRepository_DeleteAllUserSessions_Call) Run(run func(userID string)) *MockISessionRepository_DeleteAllUserSessions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockISessionRepository_DeleteAllUserSessions_Call) Return(baseError errors.BaseError) *MockISessionRepository_DeleteAllUserSessions_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockISessionRepository_DeleteAllUserSessions_Call) RunAndReturn(run func(userID string) errors.BaseError) *MockISessionRepository_DeleteAllUserSessions_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSession provides a mock function for the type MockISessionRepository
func (_mock *MockISessionRepository) DeleteSession(sessionID string) errors.BaseError {
	ret := _mock.Called(sessionID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSession")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) errors.BaseError); ok {
		r0 = returnFunc(sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockISessionRepository_DeleteSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSession'
type MockISessionRepository_DeleteSession_Call struct {
	*mock.Call
}

// DeleteSession is a helper method to define mock.On call
//   - sessionID string
func (_e *MockISessionRepository_Expecter) DeleteSession(sessionID interface{}) *MockISessionRepository_DeleteSession_Call {
	return &MockISessionRepository_DeleteSession_Call{Call: _e.mock.On("DeleteSession", sessionID)}
}

func (_c *MockISessionRepository_DeleteSession_Call) Run(run func(sessionID string)) *MockISessionRepository_DeleteSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockISessionRepository_DeleteSession_Call) Return(baseError errors.BaseError) *MockISessionRepository_DeleteSession_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockISessionRepository_DeleteSession_Call) RunAndReturn(run func(sessionID string) errors.BaseError) *MockISessionRepository_DeleteSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionByID provides a mock function for the type MockISessionRepository
func (_mock *MockISessionRepository) GetSessionByID(sessionID string) (string, string, time.Time, errors.BaseError) {
	ret := _mock.Called(sessionID)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByID")
	}

	var r0 string
	var r1 string
	var r2 time.Time
	var r3 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (string, string, time.Time, errors.BaseError)); ok {
		return returnFunc(sessionID)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(sessionID)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) string); ok {
		r1 = returnFunc(sessionID)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(string) time.Time); ok {
		r2 = returnFunc(sessionID)
	} else {
		r2 = ret.Get(2).(time.Time)
	}
	if returnFunc, ok := ret.Get(3).(func(string) errors.BaseError); ok {
		r3 = returnFunc(sessionID)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).(errors.BaseError)
		}
	}
	return r0, r1, r2, r3
}

// MockISessionRepository_GetSessionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByID'
type MockISessionRepository_GetSessionByID_Call struct {
	*mock.Call
}

// GetSessionByID is a helper method to define mock.On call
//   - sessionID string
func (_e *MockISessionRepository_Expecter) GetSessionByID(sessionID interface{}) *MockISessionRepository_GetSessionByID_Call {
	return &MockISessionRepository_GetSessionByID_Call{Call: _e.mock.On("GetSessionByID", sessionID)}
}

func (_c *MockISessionRepository_GetSessionByID_Call) Run(run func(sessionID string)) *MockISessionRepository_GetSessionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockISessionRepository_GetSessionByID_Call) Return(s string, s1 string, time1 time.Time, baseError errors.BaseError) *MockISessionRepository_GetSessionByID_Call {
	_c.Call.Return(s, s1, time1, baseError)
	return _c
}

func (_c *MockISessionRepository_GetSessionByID_Call) RunAndReturn(run func(sessionID string) (string, string, time.Time, errors.BaseError)) *MockISessionRepository_GetSessionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionByRefreshToken provides a mock function for the type MockISessionRepository
func (_mock *MockISessionRepository) GetSessionByRefreshToken(refreshToken string) (string, string, time.Time, errors.BaseError) {
	ret := _mock.Called(refreshToken)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByRefreshToken")
	}

	var r0 string
	var r1 string
	var r2 time.Time
	var r3 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (string, string, time.Time, errors.BaseError)); ok {
		return returnFunc(refreshToken)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(refreshToken)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) string); ok {
		r1 = returnFunc(refreshToken)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(string) time.Time); ok {
		r2 = returnFunc(refreshToken)
	} else {
		r2 = ret.Get(2).(time.Time)
	}
	if returnFunc, ok := ret.Get(3).(func(string) errors.BaseError); ok {
		r3 = returnFunc(refreshToken)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).(errors.BaseError)
		}
	}
	return r0, r1, r2, r3
}

// MockISessionRepository_GetSessionByRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByRefreshToken'
type MockISessionRepository_GetSessionByRefreshToken_Call struct {
	*mock.Call
}

// GetSessionByRefreshToken is a helper method to define mock.On call
//   - refreshToken string
func (_e *MockISessionRepository_Expecter) GetSessionByRefreshToken(refreshToken interface{}) *MockISessionRepository_GetSessionByRefreshToken_Call {
	return &MockISessionRepository_GetSessionByRefreshToken_Call{Call: _e.mock.On("GetSessionByRefreshToken", refreshToken)}
}

func (_c *MockISessionRepository_GetSessionByRefreshToken_Call) Run(run func(refreshToken string)) *MockISessionRepository_GetSessionByRefreshToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockISessionRepository_GetSessionByRefreshToken_Call) Return(s string, s1 string, time1 time.Time, baseError errors.BaseError) *MockISessionRepository_GetSessionByRefreshToken_Call {
	_c.Call.Return(s, s1, time1, baseError)
	return _c
}

func (_c *MockISessionRepository_GetSessionByRefreshToken_Call) RunAndReturn(run func(refreshToken string) (string, string, time.Time, errors.BaseError)) *MockISessionRepository_GetSessionByRefreshToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockITokenRepository creates a new instance of MockITokenRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockITokenRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockITokenRepository {
	mock := &MockITokenRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockITokenRepository is an autogenerated mock type for the iTokenRepository type
type MockITokenRepository struct {
	mock.Mock
}

type MockITokenRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockITokenRepository) EXPECT() *MockITokenRepository_Expecter {
	return &MockITokenRepository_Expecter{mock: &_m.Mock}
}

// BlacklistAccessToken provides a mock function for the type MockITokenRepository
func (_mock *MockITokenRepository) BlacklistAccessToken(token string, expiration time.Duration) errors.BaseError {
	ret := _mock.Called(token, expiration)

	if len(ret) == 0 {
		panic("no return value specified for BlacklistAccessToken")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, time.Duration) errors.BaseError); ok {
		r0 = returnFunc(token, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockITokenRepository_BlacklistAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlacklistAccessToken'
type MockITokenRepository_BlacklistAccessToken_Call struct {
	*mock.Call
}

// BlacklistAccessToken is a helper method to define mock.On call
//   - token string
//   - expiration time.Duration
func (_e *MockITokenRepository_Expecter) BlacklistAccessToken(token interface{}, expiration interface{}) *MockITokenRepository_BlacklistAccessToken_Call {
	return &MockITokenRepository_BlacklistAccessToken_Call{Call: _e.mock.On("BlacklistAccessToken", token, expiration)}
}

func (_c *MockITokenRepository_BlacklistAccessToken_Call) Run(run func(token string, expiration time.Duration)) *MockITokenRepository_BlacklistAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockITokenRepository_BlacklistAccessToken_Call) Return(baseError errors.BaseError) *MockITokenRepository_BlacklistAccessToken_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockITokenRepository_BlacklistAccessToken_Call) RunAndReturn(run func(token string, expiration time.Duration) errors.BaseError) *MockITokenRepository_BlacklistAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// IsAccessTokenBlacklisted provides a mock function for the type MockITokenRepository
func (_mock *MockITokenRepository) IsAccessTokenBlacklisted(token string) (bool, errors.BaseError) {
	ret := _mock.Called(token)

	if len(ret) == 0 {
		panic("no return value specified for IsAccessTokenBlacklisted")
	}

	var r0 bool
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (bool, errors.BaseError)); ok {
		return returnFunc(token)
	}
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(token)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string) errors.BaseError); ok {
		r1 = returnFunc(token)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITokenRepository_IsAccessTokenBlacklisted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsAccessTokenBlacklisted'
type MockITokenRepository_IsAccessTokenBlacklisted_Call struct {
	*mock.Call
}

// IsAccessTokenBlacklisted is a helper method to define mock.On call
//   - token string
func (_e *MockITokenRepository_Expecter) IsAccessTokenBlacklisted(token interface{}) *MockITokenRepository_IsAccessTokenBlacklisted_Call {
	return &MockITokenRepository_IsAccessTokenBlacklisted_Call{Call: _e.mock.On("IsAccessTokenBlacklisted", token)}
}

func (_c *MockITokenRepository_IsAccessTokenBlacklisted_Call) Run(run func(token string)) *MockITokenRepository_IsAccessTokenBlacklisted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITokenRepository_IsAccessTokenBlacklisted_Call) Return(b bool, baseError errors.BaseError) *MockITokenRepository_IsAccessTokenBlacklisted_Call {
	_c.Call.Return(b, baseError)
	return _c
}

func (_c *MockITokenRepository_IsAccessTokenBlacklisted_Call) RunAndReturn(run func(token string) (bool, errors.BaseError)) *MockITokenRepository_IsAccessTokenBlacklisted_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIRoleRepository creates a new instance of MockIRoleRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIRoleRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIRoleRepository {
	mock := &MockIRoleRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIRoleRepository is an autogenerated mock type for the iRoleRepository type
type MockIRoleRepository struct {
	mock.Mock
}

type MockIRoleRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIRoleRepository) EXPECT() *MockIRoleRepository_Expecter {
	return &MockIRoleRepository_Expecter{mock: &_m.Mock}
}

// UnactiveRoles provides a mock function for the type MockIRoleRepository
func (_mock *MockIRoleRepository) UnactiveRoles(userId string, roleIds []string) errors.BaseError {
	ret := _mock.Called(userId, roleIds)

	if len(ret) == 0 {
		panic("no return value specified for UnactiveRoles")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, []string) errors.BaseError); ok {
		r0 = returnFunc(userId, roleIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIRoleRepository_UnactiveRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnactiveRoles'
type MockIRoleRepository_UnactiveRoles_Call struct {
	*mock.Call
}

// UnactiveRoles is a helper method to define mock.On call
//   - userId string
//   - roleIds []string
func (_e *MockIRoleRepository_Expecter) UnactiveRoles(userId interface{}, roleIds interface{}) *MockIRoleRepository_UnactiveRoles_Call {
	return &MockIRoleRepository_UnactiveRoles_Call{Call: _e.mock.On("UnactiveRoles", userId, roleIds)}
}

func (_c *MockIRoleRepository_UnactiveRoles_Call) Run(run func(userId string, roleIds []string)) *MockIRoleRepository_UnactiveRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoleRepository_UnactiveRoles_Call) Return(baseError errors.BaseError) *MockIRoleRepository_UnactiveRoles_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIRoleRepository_UnactiveRoles_Call) RunAndReturn(run func(userId string, roleIds []string) errors.BaseError) *MockIRoleRepository_UnactiveRoles_Call {
	_c.Call.Return(run)
	return _c
}

// UnactiveRolesExcept provides a mock function for the type MockIRoleRepository
func (_mock *MockIRoleRepository) UnactiveRolesExcept(userId string, exceptRoleIds []string) errors.BaseError {
	ret := _mock.Called(userId, exceptRoleIds)

	if len(ret) == 0 {
		panic("no return value specified for UnactiveRolesExcept")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, []string) errors.BaseError); ok {
		r0 = returnFunc(userId, exceptRoleIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIRoleRepository_UnactiveRolesExcept_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnactiveRolesExcept'
type MockIRoleRepository_UnactiveRolesExcept_Call struct {
	*mock.Call
}

// UnactiveRolesExcept is a helper method to define mock.On call
//   - userId string
//   - exceptRoleIds []string
func (_e *MockIRoleRepository_Expecter) UnactiveRolesExcept(userId interface{}, exceptRoleIds interface{}) *MockIRoleRepository_UnactiveRolesExcept_Call {
	return &MockIRoleRepository_UnactiveRolesExcept_Call{Call: _e.mock.On("UnactiveRolesExcept", userId, exceptRoleIds)}
}

func (_c *MockIRoleRepository_UnactiveRolesExcept_Call) Run(run func(userId string, exceptRoleIds []string)) *MockIRoleRepository_UnactiveRolesExcept_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoleRepository_UnactiveRolesExcept_Call) Return(baseError errors.BaseError) *MockIRoleRepository_UnactiveRolesExcept_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIRoleRepository_UnactiveRolesExcept_Call) RunAndReturn(run func(userId string, exceptRoleIds []string) errors.BaseError) *MockIRoleRepository_UnactiveRolesExcept_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertRoles provides a mock function for the type MockIRoleRepository
func (_mock *MockIRoleRepository) UpsertRoles(userId string, roleIds []string) errors.BaseError {
	ret := _mock.Called(userId, roleIds)

	if len(ret) == 0 {
		panic("no return value specified for UpsertRoles")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, []string) errors.BaseError); ok {
		r0 = returnFunc(userId, roleIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIRoleRepository_UpsertRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertRoles'
type MockIRoleRepository_UpsertRoles_Call struct {
	*mock.Call
}

// UpsertRoles is a helper method to define mock.On call
//   - userId string
//   - roleIds []string
func (_e *MockIRoleRepository_Expecter) UpsertRoles(userId interface{}, roleIds interface{}) *MockIRoleRepository_UpsertRoles_Call {
	return &MockIRoleRepository_UpsertRoles_Call{Call: _e.mock.On("UpsertRoles", userId, roleIds)}
}

func (_c *MockIRoleRepository_UpsertRoles_Call) Run(run func(userId string, roleIds []string)) *MockIRoleRepository_UpsertRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoleRepository_UpsertRoles_Call) Return(baseError errors.BaseError) *MockIRoleRepository_UpsertRoles_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIRoleRepository_UpsertRoles_Call) RunAndReturn(run func(userId string, roleIds []string) errors.BaseError) *MockIRoleRepository_UpsertRoles_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateRoles provides a mock function for the type MockIRoleRepository
func (_mock *MockIRoleRepository) ValidateRoles(tenantId string, roleIds []string) errors.BaseError {
	ret := _mock.Called(tenantId, roleIds)

	if len(ret) == 0 {
		panic("no return value specified for ValidateRoles")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, []string) errors.BaseError); ok {
		r0 = returnFunc(tenantId, roleIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIRoleRepository_ValidateRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateRoles'
type MockIRoleRepository_ValidateRoles_Call struct {
	*mock.Call
}

// ValidateRoles is a helper method to define mock.On call
//   - tenantId string
//   - roleIds []string
func (_e *MockIRoleRepository_Expecter) ValidateRoles(tenantId interface{}, roleIds interface{}) *MockIRoleRepository_ValidateRoles_Call {
	return &MockIRoleRepository_ValidateRoles_Call{Call: _e.mock.On("ValidateRoles", tenantId, roleIds)}
}

func (_c *MockIRoleRepository_ValidateRoles_Call) Run(run func(tenantId string, roleIds []string)) *MockIRoleRepository_ValidateRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoleRepository_ValidateRoles_Call) Return(baseError errors.BaseError) *MockIRoleRepository_ValidateRoles_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIRoleRepository_ValidateRoles_Call) RunAndReturn(run func(tenantId string, roleIds []string) errors.BaseError) *MockIRoleRepository_ValidateRoles_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIAuditLogRepository creates a new instance of MockIAuditLogRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIAuditLogRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIAuditLogRepository {
	mock := &MockIAuditLogRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIAuditLogRepository is an autogenerated mock type for the iAuditLogRepository type
type MockIAuditLogRepository struct {
	mock.Mock
}

type MockIAuditLogRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIAuditLogRepository) EXPECT() *MockIAuditLogRepository_Expecter {
	return &MockIAuditLogRepository_Expecter{mock: &_m.Mock}
}

// CreateAuditLog provides a mock function for the type MockIAuditLogRepository
func (_mock *MockIAuditLogRepository) CreateAuditLog(auditLog *dto.AuthAuditLog) errors.BaseError {
	ret := _mock.Called(auditLog)

	if len(ret) == 0 {
		panic("no return value specified for CreateAuditLog")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*dto.AuthAuditLog) errors.BaseError); ok {
		r0 = returnFunc(auditLog)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIAuditLogRepository_CreateAuditLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAuditLog'
type MockIAuditLogRepository_CreateAuditLog_Call struct {
	*mock.Call
}

// CreateAuditLog is a helper method to define mock.On call
//   - auditLog *dto.AuthAuditLog
func (_e *MockIAuditLogRepository_Expecter) CreateAuditLog(auditLog interface{}) *MockIAuditLogRepository_CreateAuditLog_Call {
	return &MockIAuditLogRepository_CreateAuditLog_Call{Call: _e.mock.On("CreateAuditLog", auditLog)}
}

func (_c *MockIAuditLogRepository_CreateAuditLog_Call) Run(run func(auditLog *dto.AuthAuditLog)) *MockIAuditLogRepository_CreateAuditLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *dto.AuthAuditLog
		if args[0] != nil {
			arg0 = args[0].(*dto.AuthAuditLog)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIAuditLogRepository_CreateAuditLog_Call) Return(baseError errors.BaseError) *MockIAuditLogRepository_CreateAuditLog_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIAuditLogRepository_CreateAuditLog_Call) RunAndReturn(run func(auditLog *dto.AuthAuditLog) errors.BaseError) *MockIAuditLogRepository_CreateAuditLog_Call {
	_c.Call.Return(run)
	return _c
}
