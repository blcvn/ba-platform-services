// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package controllers

import (
	"context"

	"github.com/blcvn/backend/services/auth-service/common/errors"
	"github.com/blcvn/backend/services/auth-service/entities"
	"github.com/blcvn/kratos-proto/go/authen"
	mock "github.com/stretchr/testify/mock"
)

// NewMockIUtilities creates a new instance of MockIUtilities. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIUtilities(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIUtilities {
	mock := &MockIUtilities{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIUtilities is an autogenerated mock type for the iUtilities type
type MockIUtilities struct {
	mock.Mock
}

type MockIUtilities_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIUtilities) EXPECT() *MockIUtilities_Expecter {
	return &MockIUtilities_Expecter{mock: &_m.Mock}
}

// GetHeaderKey provides a mock function for the type MockIUtilities
func (_mock *MockIUtilities) GetHeaderKey(ctx context.Context, key string) string {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetHeaderKey")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, key)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockIUtilities_GetHeaderKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHeaderKey'
type MockIUtilities_GetHeaderKey_Call struct {
	*mock.Call
}

// GetHeaderKey is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockIUtilities_Expecter) GetHeaderKey(ctx interface{}, key interface{}) *MockIUtilities_GetHeaderKey_Call {
	return &MockIUtilities_GetHeaderKey_Call{Call: _e.mock.On("GetHeaderKey", ctx, key)}
}

func (_c *MockIUtilities_GetHeaderKey_Call) Run(run func(ctx context.Context, key string)) *MockIUtilities_GetHeaderKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIUtilities_GetHeaderKey_Call) Return(s string) *MockIUtilities_GetHeaderKey_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockIUtilities_GetHeaderKey_Call) RunAndReturn(run func(ctx context.Context, key string) string) *MockIUtilities_GetHeaderKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetHeaderListString provides a mock function for the type MockIUtilities
func (_mock *MockIUtilities) GetHeaderListString(ctx context.Context, key string) []string {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetHeaderListString")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = returnFunc(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// MockIUtilities_GetHeaderListString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHeaderListString'
type MockIUtilities_GetHeaderListString_Call struct {
	*mock.Call
}

// GetHeaderListString is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockIUtilities_Expecter) GetHeaderListString(ctx interface{}, key interface{}) *MockIUtilities_GetHeaderListString_Call {
	return &MockIUtilities_GetHeaderListString_Call{Call: _e.mock.On("GetHeaderListString", ctx, key)}
}

func (_c *MockIUtilities_GetHeaderListString_Call) Run(run func(ctx context.Context, key string)) *MockIUtilities_GetHeaderListString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIUtilities_GetHeaderListString_Call) Return(strings []string) *MockIUtilities_GetHeaderListString_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *MockIUtilities_GetHeaderListString_Call) RunAndReturn(run func(ctx context.Context, key string) []string) *MockIUtilities_GetHeaderListString_Call {
	_c.Call.Return(run)
	return _c
}

// GetQueryParam provides a mock function for the type MockIUtilities
func (_mock *MockIUtilities) GetQueryParam(ctx context.Context, key string) string {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetQueryParam")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, key)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockIUtilities_GetQueryParam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetQueryParam'
type MockIUtilities_GetQueryParam_Call struct {
	*mock.Call
}

// GetQueryParam is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockIUtilities_Expecter) GetQueryParam(ctx interface{}, key interface{}) *MockIUtilities_GetQueryParam_Call {
	return &MockIUtilities_GetQueryParam_Call{Call: _e.mock.On("GetQueryParam", ctx, key)}
}

func (_c *MockIUtilities_GetQueryParam_Call) Run(run func(ctx context.Context, key string)) *MockIUtilities_GetQueryParam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIUtilities_GetQueryParam_Call) Return(s string) *MockIUtilities_GetQueryParam_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockIUtilities_GetQueryParam_Call) RunAndReturn(run func(ctx context.Context, key string) string) *MockIUtilities_GetQueryParam_Call {
	_c.Call.Return(run)
	return _c
}

// SetResponseHeader provides a mock function for the type MockIUtilities
func (_mock *MockIUtilities) SetResponseHeader(ctx context.Context, key string, value string) error {
	ret := _mock.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetResponseHeader")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, key, value)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIUtilities_SetResponseHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetResponseHeader'
type MockIUtilities_SetResponseHeader_Call struct {
	*mock.Call
}

// SetResponseHeader is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
func (_e *MockIUtilities_Expecter) SetResponseHeader(ctx interface{}, key interface{}, value interface{}) *MockIUtilities_SetResponseHeader_Call {
	return &MockIUtilities_SetResponseHeader_Call{Call: _e.mock.On("SetResponseHeader", ctx, key, value)}
}

func (_c *MockIUtilities_SetResponseHeader_Call) Run(run func(ctx context.Context, key string, value string)) *MockIUtilities_SetResponseHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIUtilities_SetResponseHeader_Call) Return(err error) *MockIUtilities_SetResponseHeader_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIUtilities_SetResponseHeader_Call) RunAndReturn(run func(ctx context.Context, key string, value string) error) *MockIUtilities_SetResponseHeader_Call {
	_c.Call.Return(run)
	return _c
}

// SetResponseHeaders provides a mock function for the type MockIUtilities
func (_mock *MockIUtilities) SetResponseHeaders(ctx context.Context, key string, values []string) error {
	ret := _mock.Called(ctx, key, values)

	if len(ret) == 0 {
		panic("no return value specified for SetResponseHeaders")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) error); ok {
		r0 = returnFunc(ctx, key, values)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIUtilities_SetResponseHeaders_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetResponseHeaders'
type MockIUtilities_SetResponseHeaders_Call struct {
	*mock.Call
}

// SetResponseHeaders is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values []string
func (_e *MockIUtilities_Expecter) SetResponseHeaders(ctx interface{}, key interface{}, values interface{}) *MockIUtilities_SetResponseHeaders_Call {
	return &MockIUtilities_SetResponseHeaders_Call{Call: _e.mock.On("SetResponseHeaders", ctx, key, values)}
}

func (_c *MockIUtilities_SetResponseHeaders_Call) Run(run func(ctx context.Context, key string, values []string)) *MockIUtilities_SetResponseHeaders_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIUtilities_SetResponseHeaders_Call) Return(err error) *MockIUtilities_SetResponseHeaders_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIUtilities_SetResponseHeaders_Call) RunAndReturn(run func(ctx context.Context, key string, values []string) error) *MockIUtilities_SetResponseHeaders_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockITransform creates a new instance of MockITransform. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockITransform(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockITransform {
	mock := &MockITransform{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockITransform is an autogenerated mock type for the iTransform type
type MockITransform struct {
	mock.Mock
}

type MockITransform_Expecter struct {
	mock *mock.Mock
}

func (_m *MockITransform) EXPECT() *MockITransform_Expecter {
	return &MockITransform_Expecter{mock: &_m.Mock}
}

// Model2PbMetadata provides a mock function for the type MockITransform
func (_mock *MockITransform) Model2PbMetadata(source *entities.Metadata) (*authen.Metadata, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Model2PbMetadata")
	}

	var r0 *authen.Metadata
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.Metadata) (*authen.Metadata, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.Metadata) *authen.Metadata); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*authen.Metadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.Metadata) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Model2PbMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Model2PbMetadata'
type MockITransform_Model2PbMetadata_Call struct {
	*mock.Call
}

// Model2PbMetadata is a helper method to define mock.On call
//   - source *entities.Metadata
func (_e *MockITransform_Expecter) Model2PbMetadata(source interface{}) *MockITransform_Model2PbMetadata_Call {
	return &MockITransform_Model2PbMetadata_Call{Call: _e.mock.On("Model2PbMetadata", source)}
}

func (_c *MockITransform_Model2PbMetadata_Call) Run(run func(source *entities.Metadata)) *MockITransform_Model2PbMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.Metadata
		if args[0] != nil {
			arg0 = args[0].(*entities.Metadata)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Model2PbMetadata_Call) Return(metadata *authen.Metadata, baseError errors.BaseError) *MockITransform_Model2PbMetadata_Call {
	_c.Call.Return(metadata, baseError)
	return _c
}

func (_c *MockITransform_Model2PbMetadata_Call) RunAndReturn(run func(source *entities.Metadata) (*authen.Metadata, errors.BaseError)) *MockITransform_Model2PbMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// Model2PbSignature provides a mock function for the type MockITransform
func (_mock *MockITransform) Model2PbSignature(source *entities.Signature) (*authen.Signature, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Model2PbSignature")
	}

	var r0 *authen.Signature
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.Signature) (*authen.Signature, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.Signature) *authen.Signature); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*authen.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.Signature) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Model2PbSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Model2PbSignature'
type MockITransform_Model2PbSignature_Call struct {
	*mock.Call
}

// Model2PbSignature is a helper method to define mock.On call
//   - source *entities.Signature
func (_e *MockITransform_Expecter) Model2PbSignature(source interface{}) *MockITransform_Model2PbSignature_Call {
	return &MockITransform_Model2PbSignature_Call{Call: _e.mock.On("Model2PbSignature", source)}
}

func (_c *MockITransform_Model2PbSignature_Call) Run(run func(source *entities.Signature)) *MockITransform_Model2PbSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.Signature
		if args[0] != nil {
			arg0 = args[0].(*entities.Signature)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Model2PbSignature_Call) Return(signature *authen.Signature, baseError errors.BaseError) *MockITransform_Model2PbSignature_Call {
	_c.Call.Return(signature, baseError)
	return _c
}

func (_c *MockITransform_Model2PbSignature_Call) RunAndReturn(run func(source *entities.Signature) (*authen.Signature, errors.BaseError)) *MockITransform_Model2PbSignature_Call {
	_c.Call.Return(run)
	return _c
}

// Model2PbToken provides a mock function for the type MockITransform
func (_mock *MockITransform) Model2PbToken(source *entities.Token) (*authen.TokenMessage, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Model2PbToken")
	}

	var r0 *authen.TokenMessage
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.Token) (*authen.TokenMessage, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.Token) *authen.TokenMessage); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*authen.TokenMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.Token) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Model2PbToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Model2PbToken'
type MockITransform_Model2PbToken_Call struct {
	*mock.Call
}

// Model2PbToken is a helper method to define mock.On call
//   - source *entities.Token
func (_e *MockITransform_Expecter) Model2PbToken(source interface{}) *MockITransform_Model2PbToken_Call {
	return &MockITransform_Model2PbToken_Call{Call: _e.mock.On("Model2PbToken", source)}
}

func (_c *MockITransform_Model2PbToken_Call) Run(run func(source *entities.Token)) *MockITransform_Model2PbToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.Token
		if args[0] != nil {
			arg0 = args[0].(*entities.Token)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Model2PbToken_Call) Return(tokenMessage *authen.TokenMessage, baseError errors.BaseError) *MockITransform_Model2PbToken_Call {
	_c.Call.Return(tokenMessage, baseError)
	return _c
}

func (_c *MockITransform_Model2PbToken_Call) RunAndReturn(run func(source *entities.Token) (*authen.TokenMessage, errors.BaseError)) *MockITransform_Model2PbToken_Call {
	_c.Call.Return(run)
	return _c
}

// Model2PbUserInfo provides a mock function for the type MockITransform
func (_mock *MockITransform) Model2PbUserInfo(source *entities.UserInfo) (*authen.UserInfo, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Model2PbUserInfo")
	}

	var r0 *authen.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.UserInfo) (*authen.UserInfo, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.UserInfo) *authen.UserInfo); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*authen.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.UserInfo) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Model2PbUserInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Model2PbUserInfo'
type MockITransform_Model2PbUserInfo_Call struct {
	*mock.Call
}

// Model2PbUserInfo is a helper method to define mock.On call
//   - source *entities.UserInfo
func (_e *MockITransform_Expecter) Model2PbUserInfo(source interface{}) *MockITransform_Model2PbUserInfo_Call {
	return &MockITransform_Model2PbUserInfo_Call{Call: _e.mock.On("Model2PbUserInfo", source)}
}

func (_c *MockITransform_Model2PbUserInfo_Call) Run(run func(source *entities.UserInfo)) *MockITransform_Model2PbUserInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.UserInfo
		if args[0] != nil {
			arg0 = args[0].(*entities.UserInfo)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Model2PbUserInfo_Call) Return(userInfo *authen.UserInfo, baseError errors.BaseError) *MockITransform_Model2PbUserInfo_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockITransform_Model2PbUserInfo_Call) RunAndReturn(run func(source *entities.UserInfo) (*authen.UserInfo, errors.BaseError)) *MockITransform_Model2PbUserInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Pb2ModelLoginPayload provides a mock function for the type MockITransform
func (_mock *MockITransform) Pb2ModelLoginPayload(source *authen.LoginPayload) (*entities.LoginPayload, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Pb2ModelLoginPayload")
	}

	var r0 *entities.LoginPayload
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*authen.LoginPayload) (*entities.LoginPayload, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*authen.LoginPayload) *entities.LoginPayload); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.LoginPayload)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*authen.LoginPayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Pb2ModelLoginPayload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pb2ModelLoginPayload'
type MockITransform_Pb2ModelLoginPayload_Call struct {
	*mock.Call
}

// Pb2ModelLoginPayload is a helper method to define mock.On call
//   - source *authen.LoginPayload
func (_e *MockITransform_Expecter) Pb2ModelLoginPayload(source interface{}) *MockITransform_Pb2ModelLoginPayload_Call {
	return &MockITransform_Pb2ModelLoginPayload_Call{Call: _e.mock.On("Pb2ModelLoginPayload", source)}
}

func (_c *MockITransform_Pb2ModelLoginPayload_Call) Run(run func(source *authen.LoginPayload)) *MockITransform_Pb2ModelLoginPayload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *authen.LoginPayload
		if args[0] != nil {
			arg0 = args[0].(*authen.LoginPayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Pb2ModelLoginPayload_Call) Return(loginPayload *entities.LoginPayload, baseError errors.BaseError) *MockITransform_Pb2ModelLoginPayload_Call {
	_c.Call.Return(loginPayload, baseError)
	return _c
}

func (_c *MockITransform_Pb2ModelLoginPayload_Call) RunAndReturn(run func(source *authen.LoginPayload) (*entities.LoginPayload, errors.BaseError)) *MockITransform_Pb2ModelLoginPayload_Call {
	_c.Call.Return(run)
	return _c
}

// Pb2ModelLoginWithGooglePayload provides a mock function for the type MockITransform
func (_mock *MockITransform) Pb2ModelLoginWithGooglePayload(source *authen.LoginWithGooglePayload) (*entities.LoginPayload, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Pb2ModelLoginWithGooglePayload")
	}

	var r0 *entities.LoginPayload
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*authen.LoginWithGooglePayload) (*entities.LoginPayload, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*authen.LoginWithGooglePayload) *entities.LoginPayload); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.LoginPayload)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*authen.LoginWithGooglePayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Pb2ModelLoginWithGooglePayload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pb2ModelLoginWithGooglePayload'
type MockITransform_Pb2ModelLoginWithGooglePayload_Call struct {
	*mock.Call
}

// Pb2ModelLoginWithGooglePayload is a helper method to define mock.On call
//   - source *authen.LoginWithGooglePayload
func (_e *MockITransform_Expecter) Pb2ModelLoginWithGooglePayload(source interface{}) *MockITransform_Pb2ModelLoginWithGooglePayload_Call {
	return &MockITransform_Pb2ModelLoginWithGooglePayload_Call{Call: _e.mock.On("Pb2ModelLoginWithGooglePayload", source)}
}

func (_c *MockITransform_Pb2ModelLoginWithGooglePayload_Call) Run(run func(source *authen.LoginWithGooglePayload)) *MockITransform_Pb2ModelLoginWithGooglePayload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *authen.LoginWithGooglePayload
		if args[0] != nil {
			arg0 = args[0].(*authen.LoginWithGooglePayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Pb2ModelLoginWithGooglePayload_Call) Return(loginPayload *entities.LoginPayload, baseError errors.BaseError) *MockITransform_Pb2ModelLoginWithGooglePayload_Call {
	_c.Call.Return(loginPayload, baseError)
	return _c
}

func (_c *MockITransform_Pb2ModelLoginWithGooglePayload_Call) RunAndReturn(run func(source *authen.LoginWithGooglePayload) (*entities.LoginPayload, errors.BaseError)) *MockITransform_Pb2ModelLoginWithGooglePayload_Call {
	_c.Call.Return(run)
	return _c
}

// Pb2ModelMetadata provides a mock function for the type MockITransform
func (_mock *MockITransform) Pb2ModelMetadata(source *authen.Metadata) (*entities.Metadata, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Pb2ModelMetadata")
	}

	var r0 *entities.Metadata
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*authen.Metadata) (*entities.Metadata, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*authen.Metadata) *entities.Metadata); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.Metadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*authen.Metadata) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Pb2ModelMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pb2ModelMetadata'
type MockITransform_Pb2ModelMetadata_Call struct {
	*mock.Call
}

// Pb2ModelMetadata is a helper method to define mock.On call
//   - source *authen.Metadata
func (_e *MockITransform_Expecter) Pb2ModelMetadata(source interface{}) *MockITransform_Pb2ModelMetadata_Call {
	return &MockITransform_Pb2ModelMetadata_Call{Call: _e.mock.On("Pb2ModelMetadata", source)}
}

func (_c *MockITransform_Pb2ModelMetadata_Call) Run(run func(source *authen.Metadata)) *MockITransform_Pb2ModelMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *authen.Metadata
		if args[0] != nil {
			arg0 = args[0].(*authen.Metadata)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Pb2ModelMetadata_Call) Return(metadata *entities.Metadata, baseError errors.BaseError) *MockITransform_Pb2ModelMetadata_Call {
	_c.Call.Return(metadata, baseError)
	return _c
}

func (_c *MockITransform_Pb2ModelMetadata_Call) RunAndReturn(run func(source *authen.Metadata) (*entities.Metadata, errors.BaseError)) *MockITransform_Pb2ModelMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// Pb2ModelRegisterPayload provides a mock function for the type MockITransform
func (_mock *MockITransform) Pb2ModelRegisterPayload(source *authen.RegisterPayload) (*entities.RegisterPayload, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Pb2ModelRegisterPayload")
	}

	var r0 *entities.RegisterPayload
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*authen.RegisterPayload) (*entities.RegisterPayload, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*authen.RegisterPayload) *entities.RegisterPayload); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.RegisterPayload)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*authen.RegisterPayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Pb2ModelRegisterPayload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pb2ModelRegisterPayload'
type MockITransform_Pb2ModelRegisterPayload_Call struct {
	*mock.Call
}

// Pb2ModelRegisterPayload is a helper method to define mock.On call
//   - source *authen.RegisterPayload
func (_e *MockITransform_Expecter) Pb2ModelRegisterPayload(source interface{}) *MockITransform_Pb2ModelRegisterPayload_Call {
	return &MockITransform_Pb2ModelRegisterPayload_Call{Call: _e.mock.On("Pb2ModelRegisterPayload", source)}
}

func (_c *MockITransform_Pb2ModelRegisterPayload_Call) Run(run func(source *authen.RegisterPayload)) *MockITransform_Pb2ModelRegisterPayload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *authen.RegisterPayload
		if args[0] != nil {
			arg0 = args[0].(*authen.RegisterPayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Pb2ModelRegisterPayload_Call) Return(registerPayload *entities.RegisterPayload, baseError errors.BaseError) *MockITransform_Pb2ModelRegisterPayload_Call {
	_c.Call.Return(registerPayload, baseError)
	return _c
}

func (_c *MockITransform_Pb2ModelRegisterPayload_Call) RunAndReturn(run func(source *authen.RegisterPayload) (*entities.RegisterPayload, errors.BaseError)) *MockITransform_Pb2ModelRegisterPayload_Call {
	_c.Call.Return(run)
	return _c
}

// Pb2ModelRolePayload provides a mock function for the type MockITransform
func (_mock *MockITransform) Pb2ModelRolePayload(source *authen.RolePayload) (*entities.RolePayload, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Pb2ModelRolePayload")
	}

	var r0 *entities.RolePayload
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*authen.RolePayload) (*entities.RolePayload, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*authen.RolePayload) *entities.RolePayload); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.RolePayload)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*authen.RolePayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Pb2ModelRolePayload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pb2ModelRolePayload'
type MockITransform_Pb2ModelRolePayload_Call struct {
	*mock.Call
}

// Pb2ModelRolePayload is a helper method to define mock.On call
//   - source *authen.RolePayload
func (_e *MockITransform_Expecter) Pb2ModelRolePayload(source interface{}) *MockITransform_Pb2ModelRolePayload_Call {
	return &MockITransform_Pb2ModelRolePayload_Call{Call: _e.mock.On("Pb2ModelRolePayload", source)}
}

func (_c *MockITransform_Pb2ModelRolePayload_Call) Run(run func(source *authen.RolePayload)) *MockITransform_Pb2ModelRolePayload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *authen.RolePayload
		if args[0] != nil {
			arg0 = args[0].(*authen.RolePayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Pb2ModelRolePayload_Call) Return(rolePayload *entities.RolePayload, baseError errors.BaseError) *MockITransform_Pb2ModelRolePayload_Call {
	_c.Call.Return(rolePayload, baseError)
	return _c
}

func (_c *MockITransform_Pb2ModelRolePayload_Call) RunAndReturn(run func(source *authen.RolePayload) (*entities.RolePayload, errors.BaseError)) *MockITransform_Pb2ModelRolePayload_Call {
	_c.Call.Return(run)
	return _c
}

// Pb2ModelSignature provides a mock function for the type MockITransform
func (_mock *MockITransform) Pb2ModelSignature(source *authen.Signature) (*entities.Signature, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Pb2ModelSignature")
	}

	var r0 *entities.Signature
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*authen.Signature) (*entities.Signature, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*authen.Signature) *entities.Signature); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.Signature)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*authen.Signature) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Pb2ModelSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pb2ModelSignature'
type MockITransform_Pb2ModelSignature_Call struct {
	*mock.Call
}

// Pb2ModelSignature is a helper method to define mock.On call
//   - source *authen.Signature
func (_e *MockITransform_Expecter) Pb2ModelSignature(source interface{}) *MockITransform_Pb2ModelSignature_Call {
	return &MockITransform_Pb2ModelSignature_Call{Call: _e.mock.On("Pb2ModelSignature", source)}
}

func (_c *MockITransform_Pb2ModelSignature_Call) Run(run func(source *authen.Signature)) *MockITransform_Pb2ModelSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *authen.Signature
		if args[0] != nil {
			arg0 = args[0].(*authen.Signature)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Pb2ModelSignature_Call) Return(signature *entities.Signature, baseError errors.BaseError) *MockITransform_Pb2ModelSignature_Call {
	_c.Call.Return(signature, baseError)
	return _c
}

func (_c *MockITransform_Pb2ModelSignature_Call) RunAndReturn(run func(source *authen.Signature) (*entities.Signature, errors.BaseError)) *MockITransform_Pb2ModelSignature_Call {
	_c.Call.Return(run)
	return _c
}

// Pb2ModelUserStatusPayload provides a mock function for the type MockITransform
func (_mock *MockITransform) Pb2ModelUserStatusPayload(source *authen.UserStatusPayload) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for Pb2ModelUserStatusPayload")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*authen.UserStatusPayload) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*authen.UserStatusPayload) *entities.UserInfo); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*authen.UserStatusPayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockITransform_Pb2ModelUserStatusPayload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pb2ModelUserStatusPayload'
type MockITransform_Pb2ModelUserStatusPayload_Call struct {
	*mock.Call
}

// Pb2ModelUserStatusPayload is a helper method to define mock.On call
//   - source *authen.UserStatusPayload
func (_e *MockITransform_Expecter) Pb2ModelUserStatusPayload(source interface{}) *MockITransform_Pb2ModelUserStatusPayload_Call {
	return &MockITransform_Pb2ModelUserStatusPayload_Call{Call: _e.mock.On("Pb2ModelUserStatusPayload", source)}
}

func (_c *MockITransform_Pb2ModelUserStatusPayload_Call) Run(run func(source *authen.UserStatusPayload)) *MockITransform_Pb2ModelUserStatusPayload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *authen.UserStatusPayload
		if args[0] != nil {
			arg0 = args[0].(*authen.UserStatusPayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockITransform_Pb2ModelUserStatusPayload_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockITransform_Pb2ModelUserStatusPayload_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockITransform_Pb2ModelUserStatusPayload_Call) RunAndReturn(run func(source *authen.UserStatusPayload) (*entities.UserInfo, errors.BaseError)) *MockITransform_Pb2ModelUserStatusPayload_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIValidator creates a new instance of MockIValidator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIValidator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIValidator {
	mock := &MockIValidator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIValidator is an autogenerated mock type for the iValidator type
type MockIValidator struct {
	mock.Mock
}

type MockIValidator_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIValidator) EXPECT() *MockIValidator_Expecter {
	return &MockIValidator_Expecter{mock: &_m.Mock}
}

// ValidateLogin provides a mock function for the type MockIValidator
func (_mock *MockIValidator) ValidateLogin(source *entities.LoginPayload) errors.BaseError {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for ValidateLogin")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.LoginPayload) errors.BaseError); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIValidator_ValidateLogin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateLogin'
type MockIValidator_ValidateLogin_Call struct {
	*mock.Call
}

// ValidateLogin is a helper method to define mock.On call
//   - source *entities.LoginPayload
func (_e *MockIValidator_Expecter) ValidateLogin(source interface{}) *MockIValidator_ValidateLogin_Call {
	return &MockIValidator_ValidateLogin_Call{Call: _e.mock.On("ValidateLogin", source)}
}

func (_c *MockIValidator_ValidateLogin_Call) Run(run func(source *entities.LoginPayload)) *MockIValidator_ValidateLogin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.LoginPayload
		if args[0] != nil {
			arg0 = args[0].(*entities.LoginPayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIValidator_ValidateLogin_Call) Return(baseError errors.BaseError) *MockIValidator_ValidateLogin_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIValidator_ValidateLogin_Call) RunAndReturn(run func(source *entities.LoginPayload) errors.BaseError) *MockIValidator_ValidateLogin_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateMetadata provides a mock function for the type MockIValidator
func (_mock *MockIValidator) ValidateMetadata(source *entities.Metadata) errors.BaseError {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for ValidateMetadata")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.Metadata) errors.BaseError); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIValidator_ValidateMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateMetadata'
type MockIValidator_ValidateMetadata_Call struct {
	*mock.Call
}

// ValidateMetadata is a helper method to define mock.On call
//   - source *entities.Metadata
func (_e *MockIValidator_Expecter) ValidateMetadata(source interface{}) *MockIValidator_ValidateMetadata_Call {
	return &MockIValidator_ValidateMetadata_Call{Call: _e.mock.On("ValidateMetadata", source)}
}

func (_c *MockIValidator_ValidateMetadata_Call) Run(run func(source *entities.Metadata)) *MockIValidator_ValidateMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.Metadata
		if args[0] != nil {
			arg0 = args[0].(*entities.Metadata)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIValidator_ValidateMetadata_Call) Return(baseError errors.BaseError) *MockIValidator_ValidateMetadata_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIValidator_ValidateMetadata_Call) RunAndReturn(run func(source *entities.Metadata) errors.BaseError) *MockIValidator_ValidateMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateRegister provides a mock function for the type MockIValidator
func (_mock *MockIValidator) ValidateRegister(source *entities.RegisterPayload) errors.BaseError {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for ValidateRegister")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.RegisterPayload) errors.BaseError); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIValidator_ValidateRegister_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateRegister'
type MockIValidator_ValidateRegister_Call struct {
	*mock.Call
}

// ValidateRegister is a helper method to define mock.On call
//   - source *entities.RegisterPayload
func (_e *MockIValidator_Expecter) ValidateRegister(source interface{}) *MockIValidator_ValidateRegister_Call {
	return &MockIValidator_ValidateRegister_Call{Call: _e.mock.On("ValidateRegister", source)}
}

func (_c *MockIValidator_ValidateRegister_Call) Run(run func(source *entities.RegisterPayload)) *MockIValidator_ValidateRegister_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.RegisterPayload
		if args[0] != nil {
			arg0 = args[0].(*entities.RegisterPayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIValidator_ValidateRegister_Call) Return(baseError errors.BaseError) *MockIValidator_ValidateRegister_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIValidator_ValidateRegister_Call) RunAndReturn(run func(source *entities.RegisterPayload) errors.BaseError) *MockIValidator_ValidateRegister_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateRoles provides a mock function for the type MockIValidator
func (_mock *MockIValidator) ValidateRoles(tenantId string, roleIds []string, source *entities.RolePayload) errors.BaseError {
	ret := _mock.Called(tenantId, roleIds, source)

	if len(ret) == 0 {
		panic("no return value specified for ValidateRoles")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, []string, *entities.RolePayload) errors.BaseError); ok {
		r0 = returnFunc(tenantId, roleIds, source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIValidator_ValidateRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateRoles'
type MockIValidator_ValidateRoles_Call struct {
	*mock.Call
}

// ValidateRoles is a helper method to define mock.On call
//   - tenantId string
//   - roleIds []string
//   - source *entities.RolePayload
func (_e *MockIValidator_Expecter) ValidateRoles(tenantId interface{}, roleIds interface{}, source interface{}) *MockIValidator_ValidateRoles_Call {
	return &MockIValidator_ValidateRoles_Call{Call: _e.mock.On("ValidateRoles", tenantId, roleIds, source)}
}

func (_c *MockIValidator_ValidateRoles_Call) Run(run func(tenantId string, roleIds []string, source *entities.RolePayload)) *MockIValidator_ValidateRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 *entities.RolePayload
		if args[2] != nil {
			arg2 = args[2].(*entities.RolePayload)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIValidator_ValidateRoles_Call) Return(baseError errors.BaseError) *MockIValidator_ValidateRoles_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIValidator_ValidateRoles_Call) RunAndReturn(run func(tenantId string, roleIds []string, source *entities.RolePayload) errors.BaseError) *MockIValidator_ValidateRoles_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateSignature provides a mock function for the type MockIValidator
func (_mock *MockIValidator) ValidateSignature(source *entities.Signature) errors.BaseError {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for ValidateSignature")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.Signature) errors.BaseError); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIValidator_ValidateSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateSignature'
type MockIValidator_ValidateSignature_Call struct {
	*mock.Call
}

// ValidateSignature is a helper method to define mock.On call
//   - source *entities.Signature
func (_e *MockIValidator_Expecter) ValidateSignature(source interface{}) *MockIValidator_ValidateSignature_Call {
	return &MockIValidator_ValidateSignature_Call{Call: _e.mock.On("ValidateSignature", source)}
}

func (_c *MockIValidator_ValidateSignature_Call) Run(run func(source *entities.Signature)) *MockIValidator_ValidateSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.Signature
		if args[0] != nil {
			arg0 = args[0].(*entities.Signature)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIValidator_ValidateSignature_Call) Return(baseError errors.BaseError) *MockIValidator_ValidateSignature_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIValidator_ValidateSignature_Call) RunAndReturn(run func(source *entities.Signature) errors.BaseError) *MockIValidator_ValidateSignature_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateUser provides a mock function for the type MockIValidator
func (_mock *MockIValidator) ValidateUser(tenantId string, roleIds []string, source *entities.UserInfo) errors.BaseError {
	ret := _mock.Called(tenantId, roleIds, source)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUser")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, []string, *entities.UserInfo) errors.BaseError); ok {
		r0 = returnFunc(tenantId, roleIds, source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIValidator_ValidateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateUser'
type MockIValidator_ValidateUser_Call struct {
	*mock.Call
}

// ValidateUser is a helper method to define mock.On call
//   - tenantId string
//   - roleIds []string
//   - source *entities.UserInfo
func (_e *MockIValidator_Expecter) ValidateUser(tenantId interface{}, roleIds interface{}, source interface{}) *MockIValidator_ValidateUser_Call {
	return &MockIValidator_ValidateUser_Call{Call: _e.mock.On("ValidateUser", tenantId, roleIds, source)}
}

func (_c *MockIValidator_ValidateUser_Call) Run(run func(tenantId string, roleIds []string, source *entities.UserInfo)) *MockIValidator_ValidateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 *entities.UserInfo
		if args[2] != nil {
			arg2 = args[2].(*entities.UserInfo)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIValidator_ValidateUser_Call) Return(baseError errors.BaseError) *MockIValidator_ValidateUser_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIValidator_ValidateUser_Call) RunAndReturn(run func(tenantId string, roleIds []string, source *entities.UserInfo) errors.BaseError) *MockIValidator_ValidateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIAuthUsecase creates a new instance of MockIAuthUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIAuthUsecase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIAuthUsecase {
	mock := &MockIAuthUsecase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIAuthUsecase is an autogenerated mock type for the iAuthUsecase type
type MockIAuthUsecase struct {
	mock.Mock
}

type MockIAuthUsecase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIAuthUsecase) EXPECT() *MockIAuthUsecase_Expecter {
	return &MockIAuthUsecase_Expecter{mock: &_m.Mock}
}

// Login provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) Login(ctx context.Context, source *entities.LoginPayload) (*entities.UserData, errors.BaseError) {
	ret := _mock.Called(ctx, source)

	if len(ret) == 0 {
		panic("no return value specified for Login")
	}

	var r0 *entities.UserData
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entities.LoginPayload) (*entities.UserData, errors.BaseError)); ok {
		return returnFunc(ctx, source)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entities.LoginPayload) *entities.UserData); ok {
		r0 = returnFunc(ctx, source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *entities.LoginPayload) errors.BaseError); ok {
		r1 = returnFunc(ctx, source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIAuthUsecase_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type MockIAuthUsecase_Login_Call struct {
	*mock.Call
}

// Login is a helper method to define mock.On call
//   - ctx context.Context
//   - source *entities.LoginPayload
func (_e *MockIAuthUsecase_Expecter) Login(ctx interface{}, source interface{}) *MockIAuthUsecase_Login_Call {
	return &MockIAuthUsecase_Login_Call{Call: _e.mock.On("Login", ctx, source)}
}

func (_c *MockIAuthUsecase_Login_Call) Run(run func(ctx context.Context, source *entities.LoginPayload)) *MockIAuthUsecase_Login_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *entities.LoginPayload
		if args[1] != nil {
			arg1 = args[1].(*entities.LoginPayload)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_Login_Call) Return(userData *entities.UserData, baseError errors.BaseError) *MockIAuthUsecase_Login_Call {
	_c.Call.Return(userData, baseError)
	return _c
}

func (_c *MockIAuthUsecase_Login_Call) RunAndReturn(run func(ctx context.Context, source *entities.LoginPayload) (*entities.UserData, errors.BaseError)) *MockIAuthUsecase_Login_Call {
	_c.Call.Return(run)
	return _c
}

// LoginWithGoogle provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) LoginWithGoogle(ctx context.Context, source *entities.LoginPayload) (*entities.UserData, errors.BaseError) {
	ret := _mock.Called(ctx, source)

	if len(ret) == 0 {
		panic("no return value specified for LoginWithGoogle")
	}

	var r0 *entities.UserData
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entities.LoginPayload) (*entities.UserData, errors.BaseError)); ok {
		return returnFunc(ctx, source)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entities.LoginPayload) *entities.UserData); ok {
		r0 = returnFunc(ctx, source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *entities.LoginPayload) errors.BaseError); ok {
		r1 = returnFunc(ctx, source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIAuthUsecase_LoginWithGoogle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginWithGoogle'
type MockIAuthUsecase_LoginWithGoogle_Call struct {
	*mock.Call
}

// LoginWithGoogle is a helper method to define mock.On call
//   - ctx context.Context
//   - source *entities.LoginPayload
func (_e *MockIAuthUsecase_Expecter) LoginWithGoogle(ctx interface{}, source interface{}) *MockIAuthUsecase_LoginWithGoogle_Call {
	return &MockIAuthUsecase_LoginWithGoogle_Call{Call: _e.mock.On("LoginWithGoogle", ctx, source)}
}

func (_c *MockIAuthUsecase_LoginWithGoogle_Call) Run(run func(ctx context.Context, source *entities.LoginPayload)) *MockIAuthUsecase_LoginWithGoogle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *entities.LoginPayload
		if args[1] != nil {
			arg1 = args[1].(*entities.LoginPayload)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_LoginWithGoogle_Call) Return(userData *entities.UserData, baseError errors.BaseError) *MockIAuthUsecase_LoginWithGoogle_Call {
	_c.Call.Return(userData, baseError)
	return _c
}

func (_c *MockIAuthUsecase_LoginWithGoogle_Call) RunAndReturn(run func(ctx context.Context, source *entities.LoginPayload) (*entities.UserData, errors.BaseError)) *MockIAuthUsecase_LoginWithGoogle_Call {
	_c.Call.Return(run)
	return _c
}

// Logout provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) Logout(ctx context.Context, accessToken string, userSession *entities.UserSession) errors.BaseError {
	ret := _mock.Called(ctx, accessToken, userSession)

	if len(ret) == 0 {
		panic("no return value specified for Logout")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *entities.UserSession) errors.BaseError); ok {
		r0 = returnFunc(ctx, accessToken, userSession)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIAuthUsecase_Logout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logout'
type MockIAuthUsecase_Logout_Call struct {
	*mock.Call
}

// Logout is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
//   - userSession *entities.UserSession
func (_e *MockIAuthUsecase_Expecter) Logout(ctx interface{}, accessToken interface{}, userSession interface{}) *MockIAuthUsecase_Logout_Call {
	return &MockIAuthUsecase_Logout_Call{Call: _e.mock.On("Logout", ctx, accessToken, userSession)}
}

func (_c *MockIAuthUsecase_Logout_Call) Run(run func(ctx context.Context, accessToken string, userSession *entities.UserSession)) *MockIAuthUsecase_Logout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *entities.UserSession
		if args[2] != nil {
			arg2 = args[2].(*entities.UserSession)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_Logout_Call) Return(baseError errors.BaseError) *MockIAuthUsecase_Logout_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIAuthUsecase_Logout_Call) RunAndReturn(run func(ctx context.Context, accessToken string, userSession *entities.UserSession) errors.BaseError) *MockIAuthUsecase_Logout_Call {
	_c.Call.Return(run)
	return _c
}

// Register provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) Register(ctx context.Context, source *entities.RegisterPayload) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(ctx, source)

	if len(ret) == 0 {
		panic("no return value specified for Register")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entities.RegisterPayload) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(ctx, source)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entities.RegisterPayload) *entities.UserInfo); ok {
		r0 = returnFunc(ctx, source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *entities.RegisterPayload) errors.BaseError); ok {
		r1 = returnFunc(ctx, source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIAuthUsecase_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type MockIAuthUsecase_Register_Call struct {
	*mock.Call
}

// Register is a helper method to define mock.On call
//   - ctx context.Context
//   - source *entities.RegisterPayload
func (_e *MockIAuthUsecase_Expecter) Register(ctx interface{}, source interface{}) *MockIAuthUsecase_Register_Call {
	return &MockIAuthUsecase_Register_Call{Call: _e.mock.On("Register", ctx, source)}
}

func (_c *MockIAuthUsecase_Register_Call) Run(run func(ctx context.Context, source *entities.RegisterPayload)) *MockIAuthUsecase_Register_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *entities.RegisterPayload
		if args[1] != nil {
			arg1 = args[1].(*entities.RegisterPayload)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_Register_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIAuthUsecase_Register_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIAuthUsecase_Register_Call) RunAndReturn(run func(ctx context.Context, source *entities.RegisterPayload) (*entities.UserInfo, errors.BaseError)) *MockIAuthUsecase_Register_Call {
	_c.Call.Return(run)
	return _c
}

// RenewAccessToken provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) RenewAccessToken(ctx context.Context, accessToken string, refreshToken string) (*entities.UserData, errors.BaseError) {
	ret := _mock.Called(ctx, accessToken, refreshToken)

	if len(ret) == 0 {
		panic("no return value specified for RenewAccessToken")
	}

	var r0 *entities.UserData
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*entities.UserData, errors.BaseError)); ok {
		return returnFunc(ctx, accessToken, refreshToken)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *entities.UserData); ok {
		r0 = returnFunc(ctx, accessToken, refreshToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) errors.BaseError); ok {
		r1 = returnFunc(ctx, accessToken, refreshToken)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIAuthUsecase_RenewAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenewAccessToken'
type MockIAuthUsecase_RenewAccessToken_Call struct {
	*mock.Call
}

// RenewAccessToken is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
//   - refreshToken string
func (_e *MockIAuthUsecase_Expecter) RenewAccessToken(ctx interface{}, accessToken interface{}, refreshToken interface{}) *MockIAuthUsecase_RenewAccessToken_Call {
	return &MockIAuthUsecase_RenewAccessToken_Call{Call: _e.mock.On("RenewAccessToken", ctx, accessToken, refreshToken)}
}

func (_c *MockIAuthUsecase_RenewAccessToken_Call) Run(run func(ctx context.Context, accessToken string, refreshToken string)) *MockIAuthUsecase_RenewAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_RenewAccessToken_Call) Return(userData *entities.UserData, baseError errors.BaseError) *MockIAuthUsecase_RenewAccessToken_Call {
	_c.Call.Return(userData, baseError)
	return _c
}

func (_c *MockIAuthUsecase_RenewAccessToken_Call) RunAndReturn(run func(ctx context.Context, accessToken string, refreshToken string) (*entities.UserData, errors.BaseError)) *MockIAuthUsecase_RenewAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeAccessToken provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) RevokeAccessToken(ctx context.Context, accessToken string) errors.BaseError {
	ret := _mock.Called(ctx, accessToken)

	if len(ret) == 0 {
		panic("no return value specified for RevokeAccessToken")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) errors.BaseError); ok {
		r0 = returnFunc(ctx, accessToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIAuthUsecase_RevokeAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeAccessToken'
type MockIAuthUsecase_RevokeAccessToken_Call struct {
	*mock.Call
}

// RevokeAccessToken is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
func (_e *MockIAuthUsecase_Expecter) RevokeAccessToken(ctx interface{}, accessToken interface{}) *MockIAuthUsecase_RevokeAccessToken_Call {
	return &MockIAuthUsecase_RevokeAccessToken_Call{Call: _e.mock.On("RevokeAccessToken", ctx, accessToken)}
}

func (_c *MockIAuthUsecase_RevokeAccessToken_Call) Run(run func(ctx context.Context, accessToken string)) *MockIAuthUsecase_RevokeAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_RevokeAccessToken_Call) Return(baseError errors.BaseError) *MockIAuthUsecase_RevokeAccessToken_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIAuthUsecase_RevokeAccessToken_Call) RunAndReturn(run func(ctx context.Context, accessToken string) errors.BaseError) *MockIAuthUsecase_RevokeAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeRefreshToken provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) RevokeRefreshToken(ctx context.Context, accessToken string, refreshToken string) errors.BaseError {
	ret := _mock.Called(ctx, accessToken, refreshToken)

	if len(ret) == 0 {
		panic("no return value specified for RevokeRefreshToken")
	}

	var r0 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) errors.BaseError); ok {
		r0 = returnFunc(ctx, accessToken, refreshToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(errors.BaseError)
		}
	}
	return r0
}

// MockIAuthUsecase_RevokeRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeRefreshToken'
type MockIAuthUsecase_RevokeRefreshToken_Call struct {
	*mock.Call
}

// RevokeRefreshToken is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
//   - refreshToken string
func (_e *MockIAuthUsecase_Expecter) RevokeRefreshToken(ctx interface{}, accessToken interface{}, refreshToken interface{}) *MockIAuthUsecase_RevokeRefreshToken_Call {
	return &MockIAuthUsecase_RevokeRefreshToken_Call{Call: _e.mock.On("RevokeRefreshToken", ctx, accessToken, refreshToken)}
}

func (_c *MockIAuthUsecase_RevokeRefreshToken_Call) Run(run func(ctx context.Context, accessToken string, refreshToken string)) *MockIAuthUsecase_RevokeRefreshToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_RevokeRefreshToken_Call) Return(baseError errors.BaseError) *MockIAuthUsecase_RevokeRefreshToken_Call {
	_c.Call.Return(baseError)
	return _c
}

func (_c *MockIAuthUsecase_RevokeRefreshToken_Call) RunAndReturn(run func(ctx context.Context, accessToken string, refreshToken string) errors.BaseError) *MockIAuthUsecase_RevokeRefreshToken_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyToken provides a mock function for the type MockIAuthUsecase
func (_mock *MockIAuthUsecase) VerifyToken(accessToken string) (*entities.UserSession, errors.BaseError) {
	ret := _mock.Called(accessToken)

	if len(ret) == 0 {
		panic("no return value specified for VerifyToken")
	}

	var r0 *entities.UserSession
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string) (*entities.UserSession, errors.BaseError)); ok {
		return returnFunc(accessToken)
	}
	if returnFunc, ok := ret.Get(0).(func(string) *entities.UserSession); ok {
		r0 = returnFunc(accessToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserSession)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) errors.BaseError); ok {
		r1 = returnFunc(accessToken)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIAuthUsecase_VerifyToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyToken'
type MockIAuthUsecase_VerifyToken_Call struct {
	*mock.Call
}

// VerifyToken is a helper method to define mock.On call
//   - accessToken string
func (_e *MockIAuthUsecase_Expecter) VerifyToken(accessToken interface{}) *MockIAuthUsecase_VerifyToken_Call {
	return &MockIAuthUsecase_VerifyToken_Call{Call: _e.mock.On("VerifyToken", accessToken)}
}

func (_c *MockIAuthUsecase_VerifyToken_Call) Run(run func(accessToken string)) *MockIAuthUsecase_VerifyToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIAuthUsecase_VerifyToken_Call) Return(userSession *entities.UserSession, baseError errors.BaseError) *MockIAuthUsecase_VerifyToken_Call {
	_c.Call.Return(userSession, baseError)
	return _c
}

func (_c *MockIAuthUsecase_VerifyToken_Call) RunAndReturn(run func(accessToken string) (*entities.UserSession, errors.BaseError)) *MockIAuthUsecase_VerifyToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIRoleUsecase creates a new instance of MockIRoleUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIRoleUsecase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIRoleUsecase {
	mock := &MockIRoleUsecase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIRoleUsecase is an autogenerated mock type for the iRoleUsecase type
type MockIRoleUsecase struct {
	mock.Mock
}

type MockIRoleUsecase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIRoleUsecase) EXPECT() *MockIRoleUsecase_Expecter {
	return &MockIRoleUsecase_Expecter{mock: &_m.Mock}
}

// ActiveUser provides a mock function for the type MockIRoleUsecase
func (_mock *MockIRoleUsecase) ActiveUser(tenantId string, userId string) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(tenantId, userId)

	if len(ret) == 0 {
		panic("no return value specified for ActiveUser")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, string) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(tenantId, userId)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) *entities.UserInfo); ok {
		r0 = returnFunc(tenantId, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) errors.BaseError); ok {
		r1 = returnFunc(tenantId, userId)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIRoleUsecase_ActiveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActiveUser'
type MockIRoleUsecase_ActiveUser_Call struct {
	*mock.Call
}

// ActiveUser is a helper method to define mock.On call
//   - tenantId string
//   - userId string
func (_e *MockIRoleUsecase_Expecter) ActiveUser(tenantId interface{}, userId interface{}) *MockIRoleUsecase_ActiveUser_Call {
	return &MockIRoleUsecase_ActiveUser_Call{Call: _e.mock.On("ActiveUser", tenantId, userId)}
}

func (_c *MockIRoleUsecase_ActiveUser_Call) Run(run func(tenantId string, userId string)) *MockIRoleUsecase_ActiveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoleUsecase_ActiveUser_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIRoleUsecase_ActiveUser_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIRoleUsecase_ActiveUser_Call) RunAndReturn(run func(tenantId string, userId string) (*entities.UserInfo, errors.BaseError)) *MockIRoleUsecase_ActiveUser_Call {
	_c.Call.Return(run)
	return _c
}

// AssignRoles provides a mock function for the type MockIRoleUsecase
func (_mock *MockIRoleUsecase) AssignRoles(source *entities.RolePayload) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for AssignRoles")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.RolePayload) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.RolePayload) *entities.UserInfo); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.RolePayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIRoleUsecase_AssignRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignRoles'
type MockIRoleUsecase_AssignRoles_Call struct {
	*mock.Call
}

// AssignRoles is a helper method to define mock.On call
//   - source *entities.RolePayload
func (_e *MockIRoleUsecase_Expecter) AssignRoles(source interface{}) *MockIRoleUsecase_AssignRoles_Call {
	return &MockIRoleUsecase_AssignRoles_Call{Call: _e.mock.On("AssignRoles", source)}
}

func (_c *MockIRoleUsecase_AssignRoles_Call) Run(run func(source *entities.RolePayload)) *MockIRoleUsecase_AssignRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.RolePayload
		if args[0] != nil {
			arg0 = args[0].(*entities.RolePayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRoleUsecase_AssignRoles_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIRoleUsecase_AssignRoles_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIRoleUsecase_AssignRoles_Call) RunAndReturn(run func(source *entities.RolePayload) (*entities.UserInfo, errors.BaseError)) *MockIRoleUsecase_AssignRoles_Call {
	_c.Call.Return(run)
	return _c
}

// InactiveUser provides a mock function for the type MockIRoleUsecase
func (_mock *MockIRoleUsecase) InactiveUser(tenantId string, userId string) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(tenantId, userId)

	if len(ret) == 0 {
		panic("no return value specified for InactiveUser")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(string, string) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(tenantId, userId)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string) *entities.UserInfo); ok {
		r0 = returnFunc(tenantId, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string) errors.BaseError); ok {
		r1 = returnFunc(tenantId, userId)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIRoleUsecase_InactiveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InactiveUser'
type MockIRoleUsecase_InactiveUser_Call struct {
	*mock.Call
}

// InactiveUser is a helper method to define mock.On call
//   - tenantId string
//   - userId string
func (_e *MockIRoleUsecase_Expecter) InactiveUser(tenantId interface{}, userId interface{}) *MockIRoleUsecase_InactiveUser_Call {
	return &MockIRoleUsecase_InactiveUser_Call{Call: _e.mock.On("InactiveUser", tenantId, userId)}
}

func (_c *MockIRoleUsecase_InactiveUser_Call) Run(run func(tenantId string, userId string)) *MockIRoleUsecase_InactiveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIRoleUsecase_InactiveUser_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIRoleUsecase_InactiveUser_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIRoleUsecase_InactiveUser_Call) RunAndReturn(run func(tenantId string, userId string) (*entities.UserInfo, errors.BaseError)) *MockIRoleUsecase_InactiveUser_Call {
	_c.Call.Return(run)
	return _c
}

// OverrideRoles provides a mock function for the type MockIRoleUsecase
func (_mock *MockIRoleUsecase) OverrideRoles(source *entities.RolePayload) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for OverrideRoles")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.RolePayload) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.RolePayload) *entities.UserInfo); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.RolePayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIRoleUsecase_OverrideRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverrideRoles'
type MockIRoleUsecase_OverrideRoles_Call struct {
	*mock.Call
}

// OverrideRoles is a helper method to define mock.On call
//   - source *entities.RolePayload
func (_e *MockIRoleUsecase_Expecter) OverrideRoles(source interface{}) *MockIRoleUsecase_OverrideRoles_Call {
	return &MockIRoleUsecase_OverrideRoles_Call{Call: _e.mock.On("OverrideRoles", source)}
}

func (_c *MockIRoleUsecase_OverrideRoles_Call) Run(run func(source *entities.RolePayload)) *MockIRoleUsecase_OverrideRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.RolePayload
		if args[0] != nil {
			arg0 = args[0].(*entities.RolePayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRoleUsecase_OverrideRoles_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIRoleUsecase_OverrideRoles_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIRoleUsecase_OverrideRoles_Call) RunAndReturn(run func(source *entities.RolePayload) (*entities.UserInfo, errors.BaseError)) *MockIRoleUsecase_OverrideRoles_Call {
	_c.Call.Return(run)
	return _c
}

// UnassignRoles provides a mock function for the type MockIRoleUsecase
func (_mock *MockIRoleUsecase) UnassignRoles(source *entities.RolePayload) (*entities.UserInfo, errors.BaseError) {
	ret := _mock.Called(source)

	if len(ret) == 0 {
		panic("no return value specified for UnassignRoles")
	}

	var r0 *entities.UserInfo
	var r1 errors.BaseError
	if returnFunc, ok := ret.Get(0).(func(*entities.RolePayload) (*entities.UserInfo, errors.BaseError)); ok {
		return returnFunc(source)
	}
	if returnFunc, ok := ret.Get(0).(func(*entities.RolePayload) *entities.UserInfo); ok {
		r0 = returnFunc(source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entities.UserInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*entities.RolePayload) errors.BaseError); ok {
		r1 = returnFunc(source)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(errors.BaseError)
		}
	}
	return r0, r1
}

// MockIRoleUsecase_UnassignRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnassignRoles'
type MockIRoleUsecase_UnassignRoles_Call struct {
	*mock.Call
}

// UnassignRoles is a helper method to define mock.On call
//   - source *entities.RolePayload
func (_e *MockIRoleUsecase_Expecter) UnassignRoles(source interface{}) *MockIRoleUsecase_UnassignRoles_Call {
	return &MockIRoleUsecase_UnassignRoles_Call{Call: _e.mock.On("UnassignRoles", source)}
}

func (_c *MockIRoleUsecase_UnassignRoles_Call) Run(run func(source *entities.RolePayload)) *MockIRoleUsecase_UnassignRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *entities.RolePayload
		if args[0] != nil {
			arg0 = args[0].(*entities.RolePayload)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockIRoleUsecase_UnassignRoles_Call) Return(userInfo *entities.UserInfo, baseError errors.BaseError) *MockIRoleUsecase_UnassignRoles_Call {
	_c.Call.Return(userInfo, baseError)
	return _c
}

func (_c *MockIRoleUsecase_UnassignRoles_Call) RunAndReturn(run func(source *entities.RolePayload) (*entities.UserInfo, errors.BaseError)) *MockIRoleUsecase_UnassignRoles_Call {
	_c.Call.Return(run)
	return _c
}
